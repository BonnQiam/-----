%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsable pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{xeCJK}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small,formatcom=\xeCJKVerbAddon}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{VLSI物理设计方法学}
\date{2021 年 08 月 14 日}
\release{V0.1}
\author{QIAMKING}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{发布}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{前言}
\label{\detokenize{chapter1/index:id1}}\label{\detokenize{chapter1/index::doc}}

\section{To do}
\label{\detokenize{chapter1/To_Do:to-do}}\label{\detokenize{chapter1/To_Do::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
单元库的建立（具体）

\item {} 
\sphinxAtStartPar
单元库的类型介绍（具体）

\item {} 
\sphinxAtStartPar
时序库的建立\sphinxhyphen{}> SPICE、器件延时理论模型、线负载模型

\item {} 
\sphinxAtStartPar
功耗库

\item {} 
\sphinxAtStartPar
噪声库

\item {} 
\sphinxAtStartPar
单元 \sphinxtitleref{LEF} 文件的分类（具体）

\item {} 
\sphinxAtStartPar
工艺角

\item {} 
\sphinxAtStartPar
天线效应

\item {} 
\sphinxAtStartPar
PVT条件

\item {} 
\sphinxAtStartPar
PDK

\item {} 
\sphinxAtStartPar
Physical Design Implementation Style

\item {} 
\sphinxAtStartPar
ESD

\item {} 
\sphinxAtStartPar
electromigration

\item {} 
\sphinxAtStartPar
IR Drop

\item {} 
\sphinxAtStartPar
technology file (\sphinxtitleref{.tf})

\item {} 
\sphinxAtStartPar
TLU file

\item {} 
\sphinxAtStartPar
port 与 pin 的区别

\end{enumerate}


\section{基本概念}
\label{\detokenize{chapter1/_u57fa_u672c_u6982_u5ff5:id1}}\label{\detokenize{chapter1/_u57fa_u672c_u6982_u5ff5::doc}}

\subsection{工艺角}
\label{\detokenize{chapter1/_u57fa_u672c_u6982_u5ff5:id2}}\begin{description}
\item[{最常用的工艺角为：}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
最佳 / 最快 – BC / best case / fast

\item {} 
\sphinxAtStartPar
典型 / 正常 – TC / typical case / normal

\item {} 
\sphinxAtStartPar
最差 / 最满 – WC / worst case / slow

\end{itemize}

\end{description}


\subsection{PVT条件}
\label{\detokenize{chapter1/_u57fa_u672c_u6982_u5ff5:pvt}}
\sphinxAtStartPar
process（工艺）、temperature（温度）、voltage（电压）


\subsection{PDK}
\label{\detokenize{chapter1/_u57fa_u672c_u6982_u5ff5:pdk}}
\sphinxAtStartPar
PDK（process design kit） 主要包括技术文件（technology file）、器件模型、原理图符号（schematic symbol）、参数单元（P\sphinxhyphen{}Cell）、验证文件集（DRC/LVS/EXT）


\section{时钟信号}
\label{\detokenize{chapter1/_u65f6_u949f_u4fe1_u53f7:id1}}\label{\detokenize{chapter1/_u65f6_u949f_u4fe1_u53f7::doc}}
\sphinxAtStartPar
系统时钟、全局时钟的概念


\subsection{时钟信号的生成}
\label{\detokenize{chapter1/_u65f6_u949f_u4fe1_u53f7:id2}}

\subsection{时钟信号的特性}
\label{\detokenize{chapter1/_u65f6_u949f_u4fe1_u53f7:id3}}

\subsubsection{时钟信号的定义}
\label{\detokenize{chapter1/_u65f6_u949f_u4fe1_u53f7:id4}}

\subsubsection{时钟信号的延滞（latency）}
\label{\detokenize{chapter1/_u65f6_u949f_u4fe1_u53f7:latency}}
\sphinxAtStartPar
时钟信号的延滞（latency），又被称为插入延迟（insertion delay），包括两部分：
\begin{itemize}
\item {} 
\sphinxAtStartPar
时钟源插入延迟：来自时钟源到当前芯片时钟根节点之间的延迟

\item {} 
\sphinxAtStartPar
时钟网络插入延迟：时钟树的延迟

\end{itemize}


\subsubsection{时钟信号的抖动}
\label{\detokenize{chapter1/_u65f6_u949f_u4fe1_u53f7:id5}}
\sphinxAtStartPar
时钟信号本身的抖动（jitter）定义为信号时间与理想时间时间的偏差（deviation），又称时钟抖动为 uncertainty ，即为不确定性


\subsubsection{时钟信号的偏差}
\label{\detokenize{chapter1/_u65f6_u949f_u4fe1_u53f7:id6}}
\sphinxAtStartPar
同一时钟信号从时钟根到达任意两个寄存器的延迟（delay）之差称为偏差（skew）


\section{设计约束}
\label{\detokenize{chapter1/_u8bbe_u8ba1_u7ea6_u675f:id1}}\label{\detokenize{chapter1/_u8bbe_u8ba1_u7ea6_u675f::doc}}
\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
设计约束始终贯穿着集成电路物理实现的流程中，也是整个实现流程中体现物理设计方案质量的核心之一，本质是EDA工具通过开放设计约束入口，驱动内置封装的组合优化算法进行有方向有侧重的优化，从而尽可能实现设计者的目的
\end{sphinxadmonition}

\sphinxAtStartPar
因此物理实现的最终电路结果是与设计者施加的约束条件密切相关，同时由于物理实现的工具繁多，每个工具使用过程中中均会引入相应的设计约束，将各个阶段的设计约束进行汇总分析的工作尚未完成（ \sphinxstylestrong{待查} ）

\sphinxAtStartPar
P.S. 为了检验电路是否满足约束，自然会各类分析手段，诸如时序分析、功耗分析、信号完整性分析


\subsection{设计约束文件格式sdc.rst}
\label{\detokenize{chapter1/_u6807_u51c6_u8bbe_u8ba1_u7ea6_u675fsdc:sdc-rst}}\label{\detokenize{chapter1/_u6807_u51c6_u8bbe_u8ba1_u7ea6_u675fsdc::doc}}
\sphinxAtStartPar
设计约束文件格式 \sphinxtitleref{sdc} （Synopsys Design Constraints） 文件基于 TCL （tool command language ）格式，由 Synopsys 开发定义，起初用于电路的逻辑综合。1998年由 Cadence 公司移植用于时序控制的布局布线设计

\begin{sphinxadmonition}{warning}{警告:}
\sphinxAtStartPar
\sphinxtitleref{sdc} 文件针对电路的时序、功耗、面积等方面进行约束，从而使得芯片满足设计要求的规范。其是系统架构师、前端逻辑设计、验证设计、物理设计的接口文件与指导性要求，其正确性、完成性直接决定了芯片的最终性能
\end{sphinxadmonition}


\subsection{时钟方面的约束}
\label{\detokenize{chapter1/_u8bbe_u8ba1_u7ea6_u675f:id2}}
\sphinxAtStartPar
给出 “时钟信号”（时钟定义、时钟延滞、不确定性），进而为布局、时钟树综合、布线提供时序约束参考点

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
时钟定义将通过时钟树综合来实现，时钟延滞、时钟抖动将在静态时序分析中进行检查
\end{sphinxadmonition}


\section{Design Flow}
\label{\detokenize{chapter1/Design_Flow:design-flow}}\label{\detokenize{chapter1/Design_Flow::doc}}

\subsection{Implementation}
\label{\detokenize{chapter1/Design_Flow:implementation}}
\sphinxAtStartPar
{\hyperref[\detokenize{chapter4/index::doc}]{\sphinxcrossref{\DUrole{doc}{Synthesize}}}} ， {\hyperref[\detokenize{chapter5/index::doc}]{\sphinxcrossref{\DUrole{doc}{Floorplanning}}}}， {\hyperref[\detokenize{chapter6/index::doc}]{\sphinxcrossref{\DUrole{doc}{Placement}}}}， {\hyperref[\detokenize{chapter7/index::doc}]{\sphinxcrossref{\DUrole{doc}{CTS}}}}， {\hyperref[\detokenize{chapter8/index::doc}]{\sphinxcrossref{\DUrole{doc}{Routing}}}}

\sphinxAtStartPar
从布图规划开始，到电源规划到完成布局，每一步规划不仅仅要考虑布线的实现，还要在布局完成之后时提供好的数据环境，供时钟树综合使用


\subsection{Verification}
\label{\detokenize{chapter1/Design_Flow:verification}}
\sphinxAtStartPar
\DUrole{xref,std,std-doc}{/chapter9/index}


\section{参考}
\label{\detokenize{chapter1/_u53c2_u8003:id1}}\label{\detokenize{chapter1/_u53c2_u8003::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
陈春章, 艾霞, and 王国雄. 数字集成电路物理设计. 科学出版社, 2008.

\item {} 
\sphinxAtStartPar
Golshan, Khosrow. Physical Design Essentials. Springer Science+ Business Media, LLC, 2007.

\item {} 
\sphinxAtStartPar
IC Compiler Design Planning User Guide Version E\sphinxhyphen{}2010.12\sphinxhyphen{}SP2, March 2011

\item {} 
\sphinxAtStartPar
\sphinxurl{https://www.vlsi-backend-adventure.com/floorplan.html\#8}

\item {} 
\sphinxAtStartPar
\sphinxurl{https://lmr.fi/int/physical-design-pd-interview-questions-floorplanning/}

\end{itemize}


\chapter{Library}
\label{\detokenize{chapter2/index:library}}\label{\detokenize{chapter2/index::doc}}

\section{逻辑单元类别}
\label{\detokenize{chapter2/_u5355_u5143_u5e93_u7c7b_u522b:id1}}\label{\detokenize{chapter2/_u5355_u5143_u5e93_u7c7b_u522b::doc}}\begin{description}
\item[{标准的单元库是由不同的功能电路组成的，根据其芯片中应用场景可以分为三类：}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
标准单元（standard cell）:放置于芯片的核心区域以实现逻辑功能的粘接（glue logic）

\item {} 
\sphinxAtStartPar
宏单元（macro cell）：更为准确一点，称为 memorys and custom libraries，放置于芯片的核心区域，（至少）包括RAM、ROM、IP、COT、时钟PLL、DSP等宏单元

\item {} 
\sphinxAtStartPar
输入输出单元（I/O pad cell）：放置于芯片核心区域的周围，用于芯片信号的输入、输出、电源供给

\end{itemize}

\end{description}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{单元库种类}.png}
\end{figure}


\subsection{标准单元}
\label{\detokenize{chapter2/_u5355_u5143_u5e93_u7c7b_u522b:id2}}

\subsection{宏单元}
\label{\detokenize{chapter2/_u5355_u5143_u5e93_u7c7b_u522b:id3}}

\subsection{I/O单元}
\label{\detokenize{chapter2/_u5355_u5143_u5e93_u7c7b_u522b:i-o}}\begin{description}
\item[{输出输入单元（I/O Pad Cell）包括：}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
power I/O Pad Cell：电源单元

\item {} 
\sphinxAtStartPar
ground I/O Pad Cell：接地单元

\item {} 
\sphinxAtStartPar
signal I/O Pad Cell：输入信号、输出信号、三态、双向单元

\end{itemize}

\end{description}

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
对于输入信号单元，最重要的是要考虑静电放电 ESD (electrostatic discharge) 的防护
\end{sphinxadmonition}


\section{与单元库相关的标准数据格式文件}
\label{\detokenize{chapter2/_u5355_u5143_u5e93_u76f8_u5173_u7684_u6807_u51c6_u6570_u636e_u683c_u5f0f_u6587_u4ef6:id1}}\label{\detokenize{chapter2/_u5355_u5143_u5e93_u76f8_u5173_u7684_u6807_u51c6_u6570_u636e_u683c_u5f0f_u6587_u4ef6::doc}}

\subsection{物理库交换格式(LEF)文件}
\label{\detokenize{chapter2/_u7269_u7406_u5e93_u4ea4_u6362_u683c_u5f0f(LEF)_u6587_u4ef6:lef}}\label{\detokenize{chapter2/_u7269_u7406_u5e93_u4ea4_u6362_u683c_u5f0f(LEF)_u6587_u4ef6::doc}}
\sphinxAtStartPar
物理库文件是对版图的抽象描述，使得自动布局布线成功可能且大大提高工具效率 —— 其不考虑逻辑单元版图底层（即晶体管层面的 substrate、diffusion、polysilicon）的具体信息，只关心单元端口的属性，认为单元版图中除了端口外其余所有金属互连线都是不可布线区域

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
物理库的业界标准是 Cadence 公司开发的 \sphinxtitleref{LEF} (library exchange format) 文件格式，后缀通常为 \sphinxtitleref{lef} ，为了便于管理和应用，一般将其分为技术 \sphinxtitleref{LEF} （technology LEF）、单元 \sphinxtitleref{LEF} （cell LEF）两部分
\end{sphinxadmonition}


\subsubsection{\sphinxtitleref{LEF} 的建立}
\label{\detokenize{chapter2/_u7269_u7406_u5e93_u4ea4_u6362_u683c_u5f0f(LEF)_u6587_u4ef6:id1}}\begin{description}
\item[{需要什么：}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
单元库的 \sphinxtitleref{GDSII} 文件（版图库）

\item {} 
\sphinxAtStartPar
逻辑库（时序库）：确定单元连接端口的输入输出属性（版图无法对端口的输入输出属性进行判定）

\item {} 
\sphinxAtStartPar
工艺信息：产生技术 \sphinxtitleref{LEF}

\item {} 
\sphinxAtStartPar
映射文件：作为 \sphinxtitleref{GDSII} 文件与 \sphinxtitleref{LEF} 文件之间的转换标识文件

\end{itemize}

\end{description}

\sphinxAtStartPar
根据逻辑单元的类别，从物理单元的版图设计到建库（产生 \sphinxtitleref{LEF} ）同样分为标准单元、I/O单元、宏单元三种类型


\subsubsection{技术 \sphinxtitleref{LEF}}
\label{\detokenize{chapter2/_u7269_u7406_u5e93_u4ea4_u6362_u683c_u5f0f(LEF)_u6587_u4ef6:id2}}
\sphinxAtStartPar
定义布局布线的设计规则、Foundry 的工艺信息（包括互连线的最小间距、最小宽度、厚度、典型电阻、电容、电流密度大小、布线轨道宽度、通孔种类等）


\subsubsection{单元 \sphinxtitleref{LEF}}
\label{\detokenize{chapter2/_u7269_u7406_u5e93_u4ea4_u6362_u683c_u5f0f(LEF)_u6587_u4ef6:id3}}
\sphinxAtStartPar
定义标准单元、宏单元、I/O 单元和各种特殊单元的物理信息，例如针对布局阶段提供单元的仿真区域、对称性、面积大小；针对布线阶段提供单元输入输出端口的布线层、几何形状、不可布线区域、工艺天线效应参数


\subsection{时序库文件}
\label{\detokenize{chapter2/_u65f6_u5e8f_u5e93_u6587_u4ef6:id1}}\label{\detokenize{chapter2/_u65f6_u5e8f_u5e93_u6587_u4ef6::doc}}\begin{description}
\item[{\sphinxstylestrong{时序库} ：}] \leavevmode
\sphinxAtStartPar
是描述单元库各个单元时序信息的主要库文件，定义了每个单元不同输入情况下各个输入端口到输出端口的传播延时

\end{description}

\sphinxAtStartPar
工具通过仿真不同的工艺角（process corner condition）条件下电路的工作状态得到相应的时序数据，再将数据转换成工具可以识别的库交换文件用于芯片的时序分析

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
在建立时序库时，同时会关注时序库的应用条件，即 PVT 条件，常规情况下会考虑三种典型的工艺角条件下的晶体管中作情况
\end{sphinxadmonition}


\subsubsection{时序库的建立}
\label{\detokenize{chapter2/_u65f6_u5e8f_u5e93_u6587_u4ef6:id2}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{时序库的建立}.png}
\end{figure}

\sphinxAtStartPar
时序库文件与物理库 \sphinxtitleref{LEF} 文件是相互配合的一对文件，其所含有的库单元是根据 \sphinxtitleref{LEF} 所含有的信息，根据器件延时理论模型、SPICE网表进行仿真计算得来


\subsubsection{时序库文件格式}
\label{\detokenize{chapter2/_u65f6_u5e8f_u5e93_u6587_u4ef6:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{liberty} 是目前业界广泛使用的时序库文件格式（最早是由 Synopsys 公司开发定义），通常以 \sphinxtitleref{lib} 定义作为扩展名

\item {} 
\sphinxAtStartPar
\sphinxtitleref{ILM} 是 Synopsys 公司所开发，其时序关系简明准确地反映了接口边界的参数

\end{itemize}

\sphinxAtStartPar
下具体介绍 \sphinxtitleref{liberty} 的特征：


\subsubsection{时序库中的线负载模型}
\label{\detokenize{chapter2/_u65f6_u5e8f_u5e93_u6587_u4ef6:id4}}
\sphinxAtStartPar
时序库中的器件延时与其输入输出信号的转换时间、输出端口负载相关，其采用理想的统计值，并基于线负载模型予以表达


\subsubsection{时序库单元信息}
\label{\detokenize{chapter2/_u65f6_u5e8f_u5e93_u6587_u4ef6:id5}}
\sphinxAtStartPar
时序库中主要内容由单元信息完成，每个单元与物理库交换格式 \sphinxtitleref{LEF} 文件中的单元一一对应，每个单元的信息包括：
\begin{itemize}
\item {} 
\sphinxAtStartPar
不同时序模型下的延时时间表、功耗数值表，表述数据为不同输出复杂、输入转换时间条件下的函数

\item {} 
\sphinxAtStartPar
单元的特征，诸如其面积、静态功耗、端口名称

\item {} 
\sphinxAtStartPar
端口的逻辑关系

\item {} 
\sphinxAtStartPar
噪声

\end{itemize}

\sphinxAtStartPar
P.S. 端口分别有输入、输出、双向三种类型，其中输入端口包括它的负载电容值

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
基于单元库需要建立各种标准数据格式文件（这也是单元库建立流程的一大项工作），除了物理库之外，各种模型库文件用于描述单元库中各类单元电路在不同工作条件下的性能参数，用于电路仿真、逻辑综合、布局布线、时序分析、功耗分析等任务
\end{sphinxadmonition}

\sphinxAtStartPar
e.g. 逻辑综合产生门级网表、物理设计实现布局布线的过程中需要 \sphinxtitleref{LEF} 物理库文件、 \sphinxtitleref{lib} 时序库文件


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
抽象级别
&\sphinxstyletheadfamily 
\sphinxAtStartPar
文件格式
&\sphinxstyletheadfamily 
\sphinxAtStartPar
描述
\\
\hline
\sphinxAtStartPar
电路级
&
\sphinxAtStartPar
SPICE/CDL网表
&
\sphinxAtStartPar
用于器件级仿真、LVS检查
\\
\hline
\sphinxAtStartPar
符号级
&
\sphinxAtStartPar
逻辑图
&
\sphinxAtStartPar
用于逻辑分析,包括单元名称、符号、输入输出端口
\\
\hline
\sphinxAtStartPar
版图级
&
\sphinxAtStartPar
GDSII
&
\sphinxAtStartPar
记录版图的完整信息
\\
\hline
\sphinxAtStartPar
网表文件
&
\sphinxAtStartPar
.v/.vhd
&
\sphinxAtStartPar
/
\\
\hline
\sphinxAtStartPar
物理库文件
&
\sphinxAtStartPar
LEF
&
\sphinxAtStartPar
版图的抽象文件，主要用于布局、布线
\\
\hline
\sphinxAtStartPar
时序库文件
&
\sphinxAtStartPar
liberty
&
\sphinxAtStartPar
用于电路综合、时序分析
\\
\hline
\sphinxAtStartPar
功耗库
&
\sphinxAtStartPar
/
&
\sphinxAtStartPar
/
\\
\hline
\sphinxAtStartPar
噪声库
&
\sphinxAtStartPar
/
&
\sphinxAtStartPar
用于信号完整性分析
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{单元库建立流程}
\label{\detokenize{chapter2/_u5355_u5143_u5e93_u5efa_u7acb_u6d41_u7a0b:id1}}\label{\detokenize{chapter2/_u5355_u5143_u5e93_u5efa_u7acb_u6d41_u7a0b::doc}}\begin{description}
\item[{逻辑单元的建库流程可以归纳为以下5步 \sphinxfootnotemark[1] :}] \leavevmode%
\begin{footnotetext}[1]\phantomsection\label{\thesphinxscope.1}%
\sphinxAtStartFootnote
在实际建库过程中由于不同因素的影响通常需要反复迭代才能得到理想的单元库
%
\end{footnotetext}\ignorespaces \begin{itemize}
\item {} 
\sphinxAtStartPar
方案设计、论证

\item {} 
\sphinxAtStartPar
电路设计

\item {} 
\sphinxAtStartPar
版图设计、物理库生成

\item {} 
\sphinxAtStartPar
标准单元特征化、库模型生成

\item {} 
\sphinxAtStartPar
设计验证

\end{itemize}

\end{description}

\sphinxAtStartPar
Libraries are collections of the physical layout, abstract views, timing models, simulation or functional models, and transistor level circuit descriptions.


\chapter{Partitioning}
\label{\detokenize{chapter3/index:partitioning}}\label{\detokenize{chapter3/index::doc}}

\section{Physical Design Implementation Style}
\label{\detokenize{chapter3/index:physical-design-implementation-style}}

\subsection{展平式物理设计}
\label{\detokenize{chapter3/index:id1}}
\sphinxAtStartPar
采用自下而上的物理设计方案，芯片经过 RTL 设计仿真，通过逻辑综合产生门级网表以及相应的标准时序约束  \sphinxtitleref{SDC} 文件，再调用由上述方法产生的基本单元（标准单元库）和大模块单元（包括 COT、IP、RAM、ROM、DSP），以及这些单元的时序库，通过布局布线实现物理设计，提取RC参数进行时序分析，最后产生 \sphinxtitleref{GDSII} 文件


\subsection{层次化物理设计}
\label{\detokenize{chapter3/index:id2}}
\sphinxAtStartPar
将庞大的设计在物理设计时分割（partition）为数个模块 block ，重点处理时序复杂的模块，进而缩短设计收敛的周期，使时序问题局部化

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
此处讨论的是自上而下的层次化物理设计方法，先将设计分成数个模块，再对每个模块进行展平化处理，包括独立的布局布线等过程，直到完成相应的建模，最后在顶层完成组装设计
\end{sphinxadmonition}


\chapter{Synthesize}
\label{\detokenize{chapter4/index:synthesize}}\label{\detokenize{chapter4/index::doc}}

\section{综合阶段中的设计约束}
\label{\detokenize{chapter4/_u7efc_u5408_u9636_u6bb5_u4e2d_u7684_u8bbe_u8ba1_u7ea6_u675f:id1}}\label{\detokenize{chapter4/_u7efc_u5408_u9636_u6bb5_u4e2d_u7684_u8bbe_u8ba1_u7ea6_u675f::doc}}
\sphinxAtStartPar
约束条件主要包括时序约束、面积约束、电路的环境属性、时序和负载在不同模块间的分配()


\subsection{时序约束}
\label{\detokenize{chapter4/_u7efc_u5408_u9636_u6bb5_u4e2d_u7684_u8bbe_u8ba1_u7ea6_u675f:id2}}

\subsection{面积约束}
\label{\detokenize{chapter4/_u7efc_u5408_u9636_u6bb5_u4e2d_u7684_u8bbe_u8ba1_u7ea6_u675f:id3}}

\subsection{定义环境属性}
\label{\detokenize{chapter4/_u7efc_u5408_u9636_u6bb5_u4e2d_u7684_u8bbe_u8ba1_u7ea6_u675f:id4}}

\section{综合结果评估}
\label{\detokenize{chapter4/_u7efc_u5408_u7ed3_u679c_u8bc4_u4f30:id1}}\label{\detokenize{chapter4/_u7efc_u5408_u7ed3_u679c_u8bc4_u4f30::doc}}

\subsection{基于报告的指标分析}
\label{\detokenize{chapter4/_u7efc_u5408_u7ed3_u679c_u8bc4_u4f30:id2}}
\sphinxAtStartPar
综合后可以输出多种结果报告，最常用的是：
\begin{itemize}
\item {} 
\sphinxAtStartPar
时序/延迟报告，分析时序约束为例

\item {} 
\sphinxAtStartPar
面积报告

\item {} 
\sphinxAtStartPar
功耗报告

\end{itemize}

\sphinxAtStartPar
此时的时序分析是针对对芯片的时序进行理想情况下的 \sphinxstylestrong{零线负载模式} （zero WLM / Wire\sphinxhyphen{}Load Model）进行的延迟分析，从而验证综合后的网表是否具有较好的时序


\subsection{综合后门级仿真}
\label{\detokenize{chapter4/_u7efc_u5408_u7ed3_u679c_u8bc4_u4f30:id3}}
\sphinxAtStartPar
以 Design Compiler 为例，其流程如下：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{DC综合流程}.png}
\end{figure}

\sphinxAtStartPar
综合时基于设计约束、设计文件的信息，将RTL模块综合成门级网表，然后对综合出的网表进行评估，检验其是否满足约束条件

\begin{sphinxadmonition}{warning}{警告:}
\sphinxAtStartPar
对于整个芯片的综合，其综合过程会与单独的RTL模块的有一定的区别（待查）
\end{sphinxadmonition}


\chapter{Floorplanning}
\label{\detokenize{chapter5/index:floorplanning}}\label{\detokenize{chapter5/index::doc}}

\section{Floorplanning 概述}
\label{\detokenize{chapter5/_u6982_u8ff0:floorplanning}}\label{\detokenize{chapter5/_u6982_u8ff0::doc}}
\sphinxAtStartPar
Floorplanning 是对芯片内部结构的完整规划与设计 —— Regardless of the physical design implementation style, after physical database creation using the imported netlist and corresponding library and technology files, the first step is \sphinxstylestrong{Floorplanning}


\subsection{Objectives of Floorplanning}
\label{\detokenize{chapter5/_u6982_u8ff0:objectives-of-floorplanning}}\begin{itemize}
\item {} 
\sphinxAtStartPar
minimize the area

\item {} 
\sphinxAtStartPar
minimize the Timing

\item {} 
\sphinxAtStartPar
Reduce the wire length

\item {} 
\sphinxAtStartPar
Making routing easy

\item {} 
\sphinxAtStartPar
Reduce IR drop

\end{itemize}


\subsection{What to do in Floorplanning}
\label{\detokenize{chapter5/_u6982_u8ff0:what-to-do-in-floorplanning}}\begin{itemize}
\item {} 
\sphinxAtStartPar
确定芯片面积：the size（width and height） of the core

\item {} 
\sphinxAtStartPar
Macro / Block 的布局

\item {} 
\sphinxAtStartPar
标准单元的排列形式
\begin{itemize}
\item {} 
\sphinxAtStartPar
the shape and placement of standard cell rows

\item {} 
\sphinxAtStartPar
the shape and placement of routing channels

\item {} 
\sphinxAtStartPar
standard cell placement constraints

\end{itemize}

\item {} 
\sphinxAtStartPar
I/O 单元的布局 + 电源规划：the placement of
\begin{itemize}
\item {} 
\sphinxAtStartPar
I/O cells

\item {} 
\sphinxAtStartPar
power cells

\item {} 
\sphinxAtStartPar
ground cells

\item {} 
\sphinxAtStartPar
corner cells

\item {} 
\sphinxAtStartPar
filler pad cells

\end{itemize}

\end{itemize}


\section{布局I/O单元}
\label{\detokenize{chapter5/_u5e03_u5c40IO_u5355_u5143:i-o}}\label{\detokenize{chapter5/_u5e03_u5c40IO_u5355_u5143::doc}}
\sphinxAtStartPar
It is critical to functional operation of an ASIC design to insure:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the pads have adequate power and ground connections

\item {} 
\sphinxAtStartPar
the pads are placed properly

\end{itemize}

\sphinxAtStartPar
目的：eliminate electromigration and current\sphinxhyphen{}switching noise related problems.

\begin{sphinxadmonition}{warning}{警告:}
\sphinxAtStartPar
设置 I/O Pad Cell 约束
\end{sphinxadmonition}

\sphinxAtStartPar
以 ICC 为例，在 initializing the floorplan 之前，首先为 I/O pad cells 设置约束：

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZdl{} }set\PYGZus{}pad\PYGZus{}physical\PYGZus{}constraints
\end{sphinxVerbatim}

\sphinxAtStartPar
约束内容为指定 the pad cell ordering, orientation, placement side, offset from die edge, and pad\sphinxhyphen{}to\sphinxhyphen{}pad spacing for each I/O pad

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pad约束}.png}
\end{figure}

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
上述工作即为设置管脚约束的 \sphinxtitleref{tdf} 文件了，它指定了每个 IO cell 在整个芯片中的位置和排列顺序 —— 对于 Chip level 的设计而言，该文件主要用来定义设计中所有 IO 以及 IO Corner 的位置（上下左右的方位以及排列顺序，也可以定义具体的坐标）

\sphinxAtStartPar
如果是 Block Level的设计而言，因为设计中没有IO cell，所以可以读入pin顺序和位置的 \sphinxtitleref{tdf} 文件 —— 对于Block level的设计而言，它用来指定所有pin的位置和所用的metal的层次。
\end{sphinxadmonition}

\sphinxAtStartPar
之后在执行

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZdl{} }initialize\PYGZus{}floorplan
\end{sphinxVerbatim}

\sphinxAtStartPar
在读入管脚约束文件（ \sphinxtitleref{.tdf} 文件）后，可以创建Floorplan得到芯片大概的物理形状和尺寸，在这一步执行完毕之后，IO pad cell 或者 pin 就会按照前面的约束进行摆放。

\sphinxAtStartPar
P.S. The \sphinxstyleemphasis{`initialize\_floorplan`} command places constrained pads first. Any unconstrained pads are placed next, using any available pad location. The tool does not place unconstrained pads between consecutively ordered constrained pads

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pad_placement}.png}
\end{figure}


\section{确定芯片面积}
\label{\detokenize{chapter5/_u786e_u5b9a_u82af_u7247_u9762_u79ef:id1}}\label{\detokenize{chapter5/_u786e_u5b9a_u82af_u7247_u9762_u79ef::doc}}\begin{description}
\item[{对芯片面积大小(die size)进行确定，主要基于两个方面进行考虑：}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
成本：面积越小，单张 wafer 的产出的裸片（die）数量增加，芯片的平均成本下降

\item {} 
\sphinxAtStartPar
布线质量：设定的裸片面积过小，造成布线堵塞（routing congestion），造成长周期的设计迭代

\end{itemize}

\end{description}

\sphinxAtStartPar
一个合理的面积设定是在保证布线同时尽量节约产品成本

\sphinxAtStartPar
芯片面积的确定体现在布局规划方案所使用的 Floorplan Control Parameters上，主流上有如下两种方式


\subsection{Aspect ratio}
\label{\detokenize{chapter5/_u786e_u5b9a_u82af_u7247_u9762_u79ef:aspect-ratio}}
\sphinxAtStartPar
Aspect ratio is the ratio between vertical routing resources to horizontal routing resources.
\begin{equation}\label{equation:chapter5/确定芯片面积:math-single}
\begin{split}\text{Aspect Ratio}(Ar) = \frac{\text{Horizontal routing resource} (H)}{\text{Vertical routing resource} (V)}\end{split}
\end{equation}
\sphinxAtStartPar
Aspect ratio 指定芯片高度和宽度比值的方案 —— If you specify a ratio of 1.00, the height and width are the same and therefore the core is a square; If you specify a ratio of 3.00, the height is three times the width.

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
当设计中不含Macro时可以采用 Aspect ratio 布图规划控制参数进行试探，在最开始Trail的时候一般设置较小的利用率，看 Timing、DRC、LVS等结果如何，此时用时较短，能在短时间内给设计者一个参考，让设计者对 Floorplan 方案进行评估。如果设计的问题不大，那么可以逐渐提高利用率，减小芯片的面积。
\end{sphinxadmonition}


\subsection{Width and Height}
\label{\detokenize{chapter5/_u786e_u5b9a_u82af_u7247_u9762_u79ef:width-and-height}}
\sphinxAtStartPar
指定高度和宽度，一般对于含有Macro的设计，多用这种方案


\subsection{评估指标}
\label{\detokenize{chapter5/_u786e_u5b9a_u82af_u7247_u9762_u79ef:id2}}

\subsubsection{Core Utilization (Cu)}
\label{\detokenize{chapter5/_u786e_u5b9a_u82af_u7247_u9762_u79ef:core-utilization-cu}}
\sphinxAtStartPar
Core Utilization (\sphinxtitleref{Cu}) indicates the amount of core area used for cell placement.

\sphinxAtStartPar
The number is calculated as a ratio of the total cell area (for hard macros and standard cells or soft macro cells) to the core area.
\begin{equation}\label{equation:chapter5/确定芯片面积:math-single}
\begin{split}\text{Core Utilization(Cu)} =\frac{\text{ Standard Cell area}}{\text{Row area + Channel area}}\end{split}
\end{equation}
\sphinxAtStartPar
A core utilization of 0.8, for example, means that 80\% of the core area is used for cell placement and 20 percent is available for routing.


\subsubsection{Row to Core Ratio (Rcr):}
\label{\detokenize{chapter5/_u786e_u5b9a_u82af_u7247_u9762_u79ef:row-to-core-ratio-rcr}}
\sphinxAtStartPar
Row to Core Ratio (\sphinxtitleref{Rcr}) indicates the amount of channel space to provide for routing between the cell rows.

\sphinxAtStartPar
The smaller the number, the more space is left for routing. A value of 1.0 leaves no routing channel space.
\begin{equation}\label{equation:chapter5/确定芯片面积:math-single}
\begin{split}\text{Rcr} = \frac{\text{Row area}}{\text{Core area (H * V)}}\end{split}
\end{equation}

\subsubsection{Total utilization T(F)}
\label{\detokenize{chapter5/_u786e_u5b9a_u82af_u7247_u9762_u79ef:total-utilization-t-f}}
\sphinxAtStartPar
\sphinxstyleemphasis{Total utilization} \sphinxtitleref{T(F)} of floorplan F is derived using the following equation:
\begin{equation}\label{equation:chapter5/确定芯片面积:math-single}
\begin{split}T(F) =\frac{A(m) + A(p) + A(s)}{A}\end{split}
\end{equation}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{A(m)} ： Area occupied by macros

\item {} 
\sphinxAtStartPar
\sphinxtitleref{A(p)} ： Area occupied by Pads/ Pad fillers

\item {} 
\sphinxAtStartPar
\sphinxtitleref{A(s)} ： Area occupied by Standard Cells

\end{itemize}


\subsubsection{Cell row utilization}
\label{\detokenize{chapter5/_u786e_u5b9a_u82af_u7247_u9762_u79ef:cell-row-utilization}}
\sphinxAtStartPar
Cell row utilization \sphinxtitleref{C(F)} of floorplan F is approximated using the following equation:
\begin{equation}\label{equation:chapter5/确定芯片面积:math-single}
\begin{split}C(F) = \frac{A(s)}{A(R -\text{union}(B, E, m, p))}\end{split}
\end{equation}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{R} = All cell rows

\item {} 
\sphinxAtStartPar
\sphinxtitleref{B} = All placement blockages

\item {} 
\sphinxAtStartPar
\sphinxtitleref{E} = Exclusive Regions

\end{itemize}


\section{布局Macro}
\label{\detokenize{chapter5/_u5e03_u5c40Macro:macro}}\label{\detokenize{chapter5/_u5e03_u5c40Macro::doc}}
\sphinxAtStartPar
若采用展平式物理设计方案，则设计中仅仅由 Macro 和标准单元构成；若采用层次化物理设计方案，则经过 Partitioning 后，顶层设计主要由 Macro、sub\sphinxhyphen{}system级别的 Block 构成

\sphinxAtStartPar
在 Floorplan 阶段，对于前者主要是考虑 Macro 的放置，后者则是要考虑 Macro、Block 的放置

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
Before staring of Floorplan, it is better to have \sphinxstylestrong{basic design understanding} , data flow of the design, integration guidelines of any special analog hard IPs in the design. And for block/partition level designs understanding the placement \& IO interactions of the block in Full chip will help in coming up with good floorplan.
\end{sphinxadmonition}

\sphinxAtStartPar
Macro / Block 的放置显著依赖于设计者的经验，摆放它们时要考虑面积、互连线长等传统问题，还需要考虑Macro / Block 的摆放对于 Place 的影响


\subsection{(Macro) Floorplan Techniques}
\label{\detokenize{chapter5/_u5e03_u5c40Macro:macro-floorplan-techniques}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{floorplantechniques}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Abutted floorplan : Channel less placement of blocks.

\item {} 
\sphinxAtStartPar
Non\sphinxhyphen{}Abutted / Channeled floorplan  : Channel based placement of blocks.

\item {} 
\sphinxAtStartPar
Mix / Narrow\sphinxhyphen{}Channel floorplan : partially abutted with some channels.

\end{itemize}


\subsection{Macro 放置原则：边缘摆放}
\label{\detokenize{chapter5/_u5e03_u5c40Macro:id1}}\begin{description}
\item[{边缘摆放的出发动机主要来源于下面两点：}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
从目前芯片设计的趋势来看，芯片中除了计算单元外就是随机存储单元RAM、只读存储单元ROM等。这些存储单元占据的芯片面积在有些设计中甚至超过百分之五十
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
对于存储单元来说，存在数据端口和存储端口，并且周围需要有一些可测性电路。这使得这些单元引线众多且功耗巨大

\item {} 
\sphinxAtStartPar
将它们*贴边放置*，不仅有利于这些单元的供电，而且防止这些单元过多的引脚对其他单元的布线造成影响。

\end{enumerate}

\item {} 
\sphinxAtStartPar
标准单元在布局时，按照Row所划定的高度一排一排的摆放
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
既有利于算法的设计，又有利于工业制造。

\item {} 
\sphinxAtStartPar
在给各个器件供电时，可以使用横向的电源线将处于同一高度的器件连接在一起统一供电

\end{enumerate}

\item {} 
\sphinxAtStartPar
将标准单元都摆放在芯片区域的中心，而大的Macro摆放在四周，就可以使标准单元方便的只用一条电源线连接在一起，而不会被高度不统一的Macro打断。对电源网格的设计提供了巨大便利

\end{enumerate}

\end{description}

\sphinxAtStartPar
Macro的摆放原则基本如下，可以参照下面这张图

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{test}.png}
\end{figure}

\sphinxAtStartPar
1）Macro 尽量摆放在靠近相应输入输出口（IO pad cell）的位置

\sphinxAtStartPar
一般来说对于大型的Macro，他们不仅仅需要与芯片内部的其他Macro或者标准单元进行数据交换，还需要与芯片外部的器件进行通信。

\sphinxAtStartPar
比如，锁相环单元需要接收外部晶振信号，存储单元需要接收外部地址等。这种数据交换就是靠 IO pad cell 进行的，因此摆放在离相应的数据端口附近，有利于减少互联线长度，减少线上延迟，并节约布线资源。

\sphinxAtStartPar
2）大的Macro摆放尽量贴近版图的边缘和角落，这样有利于空间的利用，要尽量留出一个连续且尽量接近圆形/方形的Core区域来摆放标准单元。

\sphinxAtStartPar
3）Macro与Macro之间要留有一定空隙，给予布线资源。

\sphinxAtStartPar
特别是在Macro的间隙有端口的时候更是如此，设计者可以通过相邻Marco边界上端口的多少来决定留有多大的间隙比较合适，这样才不至于出现Pin Access的问题

\sphinxAtStartPar
4）合理设置Macro摆放的角度。在考量Macro摆放的角度时，不仅仅考虑空间摆放的因素，还要根据端口的连接关系与互连Macro的位置来决定。

\sphinxAtStartPar
如前面原理图中存储Macro的端口方向朝向中央，因为中间的标准单元需要与存储Macro进行数据交换，存在互连关系。在实际设计时，不仅要根据端口与标准单元之间的连接关系，还要考虑Macro与Macro之间的互连关系进行综合判断。

\sphinxAtStartPar
手工对宏单元进行摆放后，需要将他们设置为dont\_touch属性，以防止在布局阶段软件对它进行移动。命令为：

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+go}{set\PYGZus{}dont\PYGZus{}touch\PYGZus{}placement[all\PYGZus{}macro\PYGZus{}cells]}
\end{sphinxVerbatim}


\subsection{Halo}
\label{\detokenize{chapter5/_u5e03_u5c40Macro:halo}}
\sphinxAtStartPar
在使用EDA软件的Floorplan设计时，同样可以给 Macro加上 \sphinxstylestrong{晕环} （ \sphinxtitleref{halo} ）来控制 Macro 与 Macro 之间的距离 —— 设置不允许摆放标准单元晕道的目的是为了能够提供专用的布线空间
\begin{quote}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{halo}.jpg}
\end{figure}
\end{quote}

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
在ICC中这被称为 \sphinxtitleref{Keepout Margin}，有 \sphinxtitleref{hard} 、 \sphinxtitleref{soft} 之分:

\sphinxAtStartPar
(1)hard区域不允许任何Cell放置在该区域
(2)soft则在coarse place的时候不允许任何Cell放入其内，但是在optimization以及legalization的时候是允许Cell放入其内的，也就是只允许Buffer加入其中

\sphinxAtStartPar
Keepout Margin与Placement Blockage不同，它并不是独立存在的，而是依附于Macro周围，可随Macro移动的。所以它是专门用来控制Macro和其他单元之间距离的一种功能。
\end{sphinxadmonition}

\sphinxAtStartPar
在基于标准单元的设计中，标准单元在布局（place）阶段完成了整个芯片内部的摆放，由于标准单元占据了底层金属的绝大多数布线轨道，当芯片局部出现拥塞时，布线晕道就能够提供更多底层的布线通道


\section{布局Block}
\label{\detokenize{chapter5/_u5e03_u5c40Block:block}}\label{\detokenize{chapter5/_u5e03_u5c40Block::doc}}
\sphinxAtStartPar
若采用展平式物理设计方案，则设计中仅仅由 Macro 和标准单元构成；若采用层次化物理设计方案，则经过 Partitioning 后，顶层设计主要由 Macro、sub\sphinxhyphen{}system级别的 Block 构成

\sphinxAtStartPar
在 Floorplan 阶段，对于前者主要是考虑 Macro 的放置，后者则是要考虑 Macro、Block 的放置

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
在层次化设计中，对于对于各个预计分割的区域之间也需要进行布线通道的定义。布线通道的宽度需要考虑模块布局的拓扑约束，诸如：
\end{sphinxadmonition}
\begin{itemize}
\item {} 
\sphinxAtStartPar
子模块到子模块的界限

\item {} 
\sphinxAtStartPar
子模块之间的距离、顺序、排列

\item {} 
\sphinxAtStartPar
子模块之间的表面比率、网络权重、子模块隔离区

\end{itemize}

\sphinxAtStartPar
该部分请参考 Placement 部分


\subsection{布局障碍}
\label{\detokenize{chapter5/_u5e03_u5c40Block:id1}}\begin{description}
\item[{\sphinxstylestrong{blockages} :}] \leavevmode
\sphinxAtStartPar
are specific location where placing of cells are blocked, acts like guidelines for placement of std cells.

\end{description}

\sphinxAtStartPar
blockages will not be guiding the tool to place the std cells at some particular area, but it won’t allow the tool to place the std cell in the blocked area

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
在 Placement、Routing 阶段都存在 Blockage，均有如下分类

\sphinxAtStartPar
1）Hard Blockages

\sphinxAtStartPar
2）Soft Blockages

\sphinxAtStartPar
3）Partial Blockages
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
分类
&\sphinxstyletheadfamily 
\sphinxAtStartPar
特征
&\sphinxstyletheadfamily 
\sphinxAtStartPar
目的
\\
\hline
\sphinxAtStartPar
Hard Blockage
&
\sphinxAtStartPar
Complete Standard Cell Blockage
&
\sphinxAtStartPar
（1）avoid routing congestion at macro corners（2）Restrict std cells to certain regions in the design（3）control power rail generation at macro cells
\\
\hline
\sphinxAtStartPar
Soft Blockage
&
\sphinxAtStartPar
Non\sphinxhyphen{}Buffering Blockage
&
\sphinxAtStartPar
only buffers can be placed and std cells cannot be placed
\\
\hline
\sphinxAtStartPar
Partial Blockage
&
\sphinxAtStartPar
Partial Standard Cell Blockage
&
\sphinxAtStartPar
（1）used to avoid congestion（2）can Block Standard Cells as per the required percentage value
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{电源规划}
\label{\detokenize{chapter5/_u7535_u6e90_u89c4_u5212:id1}}\label{\detokenize{chapter5/_u7535_u6e90_u89c4_u5212::doc}}

\section{时钟规划}
\label{\detokenize{chapter5/_u65f6_u949f_u89c4_u5212:id1}}\label{\detokenize{chapter5/_u65f6_u949f_u89c4_u5212::doc}}
\sphinxAtStartPar
Although most ASIC designs use clock tree synthesis, clock tree synthesis
may not be sufficient for very high\sphinxhyphen{}performance and synchronized designs.

\sphinxAtStartPar
In this case, one needs to implement the distributed clock networks manually
in order to minimize the skew between communicating elements due to their
line resistance and capacitance.

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
注意：Floorplanning阶段的时钟网络分布与常规的时钟树综合，其依赖于手动布图规划
\end{sphinxadmonition}


\section{Evaluate Floorplanning}
\label{\detokenize{chapter5/Floorplanning_u7684_u8bc4_u4f30:evaluate-floorplanning}}\label{\detokenize{chapter5/Floorplanning_u7684_u8bc4_u4f30::doc}}
\sphinxAtStartPar
在布图规划、布局中需要多次迭代分析，从而实现最佳效果


\subsection{布局规划阶段的延迟预估}
\label{\detokenize{chapter5/Floorplanning_u7684_u8bc4_u4f30:id1}}

\subsection{Macro布放与布线通道的关系}
\label{\detokenize{chapter5/Floorplanning_u7684_u8bc4_u4f30:macro}}
\sphinxAtStartPar
Macro布放的结果会对前期布图规划的期望目标产生直接影响，其中 \sphinxstylestrong{能够保证布线的完成是通过布线通道的分析来进行}

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
介绍相关概念：

\sphinxAtStartPar
（1）布线轨道（routing track）：芯片内部专门用于布线的路径

\sphinxAtStartPar
（2）布线通道（routing channel）：每两条 / 多条布线轨道的空间
\end{sphinxadmonition}

\sphinxAtStartPar
先前介绍的晕道，实现了预留底层布线通道，解决了当前局部拥塞的问题，但是也会产生其他区域的拥塞问题


\subsection{Block / Macro 自动放置的算法推进}
\label{\detokenize{chapter5/Floorplanning_u7684_u8bc4_u4f30:block-macro}}
\sphinxAtStartPar
现代 Soc 设计可以包含数百或更多个 Block，此时就必须借助 EDA 工具来实现 Block 的自动布局

\begin{sphinxadmonition}{warning}{警告:}
\sphinxAtStartPar
\sphinxstylestrong{To do} ：fly lines、布局障碍、电源规划、时钟规划、Floorplanning 评估
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
在正式开始 Floorplanning 之前，还有两项预备工作，分别是

\sphinxAtStartPar
（1）  \sphinxtitleref{Connecting Power and Ground Ports} ：create logical connections between power
and ground pins on standard cells and macros and the power and ground nets in the design

\sphinxAtStartPar
（2） 产生设计中原本不存在但是物理实现必要的单元 \sphinxtitleref{Adding Power, Ground, and Corner Cells}：Physical\sphinxhyphen{}only cells for power, ground, and corner placement might not be part of the
synthesized netlist and must be added to design.
\end{sphinxadmonition}


\section{与布局（Placement）、布线（Routing）的关系}
\label{\detokenize{chapter5/index:placement-routing}}
\sphinxAtStartPar
Marco、I/O pad cell 、Block 的布放在结果上属于布局，但是其又在布局规划阶段完成，由于其占据的面积（空间）很大，只有 Marco、I/O pad cell 的布放完成后，电源规划才有意义


\chapter{Placement}
\label{\detokenize{chapter6/index:placement}}\label{\detokenize{chapter6/index::doc}}
\sphinxAtStartPar
由于 I/O pad cell、macro 的布放都在布图规划时已经完成，对于 \sphinxstylestrong{展平式布局} 而言，Placement 的剩余任务主要是对标准单元的布局

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{placement}.JPG}
\end{figure}

\sphinxAtStartPar
Placement is the process of placing standard cell in the design, The tool determines the location of each standard cell on the die.
\begin{itemize}
\item {} 
\sphinxAtStartPar
place the standard cells available in the synthesized netlist

\item {} 
\sphinxAtStartPar
optimizes the design

\item {} 
\sphinxAtStartPar
determines the routability of design.

\end{itemize}

\sphinxAtStartPar
Placement will be driven by different criteria like \sphinxstylestrong{timing driven} ,  \sphinxstylestrong{congestion driven} and  \sphinxstylestrong{power optimization}


\section{布局过程与算法}
\label{\detokenize{chapter6/_u5e03_u5c40_u8fc7_u7a0b_u4e0e_u7b97_u6cd5:id1}}\label{\detokenize{chapter6/_u5e03_u5c40_u8fc7_u7a0b_u4e0e_u7b97_u6cd5::doc}}

\subsection{Global Placement}
\label{\detokenize{chapter6/_u5e03_u5c40_u8fc7_u7a0b_u4e0e_u7b97_u6cd5:global-placement}}

\subsection{Detailed Placement}
\label{\detokenize{chapter6/_u5e03_u5c40_u8fc7_u7a0b_u4e0e_u7b97_u6cd5:detailed-placement}}

\section{布局方案评估}
\label{\detokenize{chapter6/_u5e03_u5c40_u65b9_u6848_u8bc4_u4f30:id1}}\label{\detokenize{chapter6/_u5e03_u5c40_u65b9_u6848_u8bc4_u4f30::doc}}
\sphinxAtStartPar
在完成标准单元布局优化完成后，需要对设计进行拥堵分析、静态时序分析、噪声分析、电源分析来评估布局方案的质量


\subsection{拥塞}
\label{\detokenize{chapter6/_u5e03_u5c40_u65b9_u6848_u8bc4_u4f30:id2}}
\sphinxAtStartPar
查看布局之后的拥塞
.. code\sphinxhyphen{}block:: console
\begin{quote}
\begin{quote}\begin{description}
\item[{linenos}] \leavevmode
\end{description}\end{quote}

\sphinxAtStartPar
\$ report\_congestion
\end{quote}


\subsection{时序}
\label{\detokenize{chapter6/_u5e03_u5c40_u65b9_u6848_u8bc4_u4f30:id3}}
\sphinxAtStartPar
报告最大路径延时，查看是否存在Setup Slack

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZdl{} }report\PYGZus{}timing
\end{sphinxVerbatim}

\sphinxAtStartPar
报告是否存在时序 DRC 的违反

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZdl{} }report\PYGZus{}constraint\PYGZhy{}all\PYGZus{}violators
\end{sphinxVerbatim}

\sphinxAtStartPar
此时设计中最好不要存在 Setup 的违反，可以存在Max Cap/tran、hold、Min Cap的违反


\subsubsection{MCMM}
\label{\detokenize{chapter6/_u5e03_u5c40_u65b9_u6848_u8bc4_u4f30:mcmm}}
\sphinxAtStartPar
如果设计中有 MCMM，那么可以用下面的命令产生 MCMM 的报告同时产生相应的网页文件，方便查看：

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZdl{} }create\PYGZus{}qor\PYGZus{}snapshot\PYGZhy{}name cel\PYGZus{}name
\end{sphinxVerbatim}


\section{层次化布局}
\label{\detokenize{chapter6/_u5c42_u6b21_u5316_u5e03_u5c40:id1}}\label{\detokenize{chapter6/_u5c42_u6b21_u5316_u5e03_u5c40::doc}}

\chapter{CTS}
\label{\detokenize{chapter7/index:cts}}\label{\detokenize{chapter7/index::doc}}

\section{Terminology}
\label{\detokenize{chapter7/Terminology:terminology}}\label{\detokenize{chapter7/Terminology::doc}}\begin{description}
\item[{\sphinxstylestrong{时钟树} ：}] \leavevmode
\sphinxAtStartPar
时钟信号在物理设计的实现结果被形象地称为时钟树

\item[{\sphinxstylestrong{根节点} ：}] \leavevmode
\sphinxAtStartPar
时钟信号的起点

\item[{\sphinxstylestrong{叶节点} ：}] \leavevmode
\sphinxAtStartPar
时钟信号经过一系列分布节点最终到达的寄存器时钟输入端或其他时钟终点

\item[{\sphinxstylestrong{根单元} 、 \sphinxstylestrong{分布单元} 、 \sphinxstylestrong{叶单元} ：}] \leavevmode
\sphinxAtStartPar
根节点、分布节点、叶节点所依附于的逻辑单元

\item[{\sphinxstylestrong{时钟树综合} ：}] \leavevmode
\sphinxAtStartPar
根据芯片时钟网络的设计约束要求，时钟网络从根节点逐级插入驱动器（ buffer、inverter）从而到达根节点，进而产生时钟树的过程

\end{description}


\section{时钟树结构}
\label{\detokenize{chapter7/_u65f6_u949f_u6811_u7ed3_u6784:id1}}\label{\detokenize{chapter7/_u65f6_u949f_u6811_u7ed3_u6784::doc}}

\section{时钟树约束文件}
\label{\detokenize{chapter7/_u65f6_u949f_u6811_u7ea6_u675f_u6587_u4ef6:id1}}\label{\detokenize{chapter7/_u65f6_u949f_u6811_u7ea6_u675f_u6587_u4ef6::doc}}
\sphinxAtStartPar
根据标准设计约束文件 \sphinxtitleref{sdc} 的要求，产生时钟树约束文件（之后借助于 EDA 工具进行时钟树综合）


\section{时钟树综合过程及算法}
\label{\detokenize{chapter7/_u65f6_u949f_u6811_u7efc_u5408_u8fc7_u7a0b_u53ca_u7b97_u6cd5:id1}}\label{\detokenize{chapter7/_u65f6_u949f_u6811_u7efc_u5408_u8fc7_u7a0b_u53ca_u7b97_u6cd5::doc}}
\sphinxAtStartPar
根据时钟树约束文件中对每个时钟定义的参数，时钟树综合工具从标准单元布局开始：
\begin{itemize}
\item {} 
\sphinxAtStartPar
计算从时钟根节点到每一个叶节点的延迟

\item {} 
\sphinxAtStartPar
插入 buffer / inverter，减小并平衡所有叶节点的延时，使得它们之间的最大差值小于或等于最大插值，同时还要满足其他约束参数条件

\item {} 
\sphinxAtStartPar
调用布局工具调整新插入的时钟 buffer / inverter 位置

\end{itemize}

\begin{sphinxadmonition}{note}{注解:}
\sphinxAtStartPar
布线阶段并没有开始，时钟树综合工具根据时钟树单元布局的位置去估算互连线的总延时 —— 相应的，在布线时优先对时钟树进行，以保证时钟树的最大偏差不致受到影响
\end{sphinxadmonition}


\section{时钟树对电路性能（功能）的影响}
\label{\detokenize{chapter7/_u65f6_u949f_u6811_u5bf9_u7535_u8def_u6027_u80fd_uff08_u529f_u80fd_uff09_u7684_u5f71_u54cd:id1}}\label{\detokenize{chapter7/_u65f6_u949f_u6811_u5bf9_u7535_u8def_u6027_u80fd_uff08_u529f_u80fd_uff09_u7684_u5f71_u54cd::doc}}
\sphinxAtStartPar
从布图规划开始，到电源规划到完成布局之后要提供好的数据环境，供时钟树综合使用
\begin{itemize}
\item {} 
\sphinxAtStartPar
物理库、时序库、设计数据、约束参数

\item {} 
\sphinxAtStartPar
能够建立时钟树的特殊内容，例如时钟信号和特点、 时钟树的特诊和类型、时钟树约束参数

\end{itemize}


\chapter{Routing}
\label{\detokenize{chapter8/index:routing}}\label{\detokenize{chapter8/index::doc}}

\section{Special Routing}
\label{\detokenize{chapter8/special_routing:special-routing}}\label{\detokenize{chapter8/special_routing::doc}}

\section{布线过程与算法}
\label{\detokenize{chapter8/_u5e03_u7ebf_u8fc7_u7a0b_u4e0e_u7b97_u6cd5:id1}}\label{\detokenize{chapter8/_u5e03_u7ebf_u8fc7_u7a0b_u4e0e_u7b97_u6cd5::doc}}

\section{布线方案评估}
\label{\detokenize{chapter8/_u5e03_u7ebf_u65b9_u6848_u8bc4_u4f30:id1}}\label{\detokenize{chapter8/_u5e03_u7ebf_u65b9_u6848_u8bc4_u4f30::doc}}
\begin{sphinxadmonition}{warning}{警告:}
\sphinxAtStartPar
按照设计的需求将所有的信号线布通是首要评估指标
\end{sphinxadmonition}

\sphinxAtStartPar
衡量布线质量以及后续的优先方向主要以如下几个指标为主
\begin{itemize}
\item {} 
\sphinxAtStartPar
（消除）布线拥塞 congestion

\item {} 
\sphinxAtStartPar
（优化）时序（timing）

\item {} 
\sphinxAtStartPar
（减小）耦合效应（coupling）

\item {} 
\sphinxAtStartPar
（消除）窜扰（crosstalk）

\item {} 
\sphinxAtStartPar
（降低）功耗

\item {} 
\sphinxAtStartPar
（保证）信号完整性（signal integrity）

\item {} 
\sphinxAtStartPar
（预防）DFM 问题、（提高）良品率

\end{itemize}

\sphinxAtStartPar
布线的内容是将分布在芯片核内的 Macro、标准单元、I/O pad cell 按照逻辑关系进行互连（百分之百地完成所有逻辑信号的正确互连），且满足设计约束条件



\renewcommand{\indexname}{索引}
\printindex
\end{document}